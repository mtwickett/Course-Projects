---
title: "Creating An Effective Data Analysis Workflow Guided Project Part 1 and 2"
output: github_document
---

### Part 1 Project Outline

In this project we have been asked to find the most profitable R programming books sold by a fictional company. 

### The Data

The data set can be found [here](https://data.world/dataquest/book-reviews). It includes simulated programming textbook sales and reviews.

### Download And Clean The Data

```{r include=FALSE}
library("tidyverse")
library("sqldf")
library("knitr")
library("rmarkdown")
library("lubridate")
```

```{r}
df <- read.csv("C:/Users/Martin/Desktop/Datasets/dataquest-book-reviews/book_reviews.csv")
head(df)
```

```{r}
glimpse(df)
```
The data set has **`4 columns`** and **`2000 rows`**. The column types are **`character`** except the **`price`** column which is type **`double`**.  

```{r}
unique(df[c('review')])
```

```{r}
unique(df[c('book')])
```

```{r}
max(df$price)
```
```{r}
min(df$price)
```
The review column has NA values. Prices ranges between $15.99 and $50

### Remove Rows With NA

In this project the NA values will be removed rather than using imputation.

```{r}
cbind(
  lapply(
    lapply(
      df, is.na), sum
  )
)
```

```{r}
df <- df %>% filter(
  !(is.na(df$review))
)
print(sum(is.na(df$review)))
nrow(df)
```
206 rows with NA in the **`review`** column have been removed from the data set leaving 1794 rows.

```{r}
unique(df[c('state')])
```

### Make State Column Values Consistent

```{r}
df <- df %>% mutate(
  state = case_when(
    state == 'Texas' ~ 'TX',
    state == 'Florida' ~ 'FL',
    state == 'California' ~ 'CA',
    state == 'New York' ~ 'NY',
    TRUE ~ state
  )
)
unique(df[c('state')])
```
### Convert Review Values to Numeric Form

```{r}
unique(df[c('review')])
```


```{r}
df <- df %>% mutate(
  review_num = case_when(
    review == 'Excellent' ~ 5,
    review == 'Great' ~ 4,
    review == 'Good' ~ 3,
    review == 'Fair' ~ 2,
    review == 'Poor' ~ 1
  ),
  is_high_review = review_num >= 4
)
head(df)
```

### Find What Books Are Most Profitable


```{r}
price_df <- df[c('book', 'price')] %>% 
  group_by(book) %>%
  summarise(mean(price))
price_df
```

```{r}
most_profitable <- df %>% group_by(book) %>%
  summarise(total_profit = sum(price),
            total_sales = length(book),
            percent_reviews_above_good = round(length(is_high_review[is_high_review == TRUE]) / total_sales * 100, 1)) %>% 
  arrange(-total_profit)
most_profitable
```

The most profitable book is **`Secrets Of R For Advanced Students`**. This is also the most expensive book at $50.

### Part 2 Project Outline

The company has updated data based on a new marketing program. They want to know if this new program has improved sales.

```{r}
df2 <- read_csv('C:/Users/Martin/Desktop/Datasets/dataquest-book-sales-data/sales2019.csv')
head(df2)
```
```{r}
glimpse(df2)
```

```{r}
cbind(
  lapply(
    lapply(df2, is.na), sum)
  )
```
```{r}
min(df2$date)
```
```{r}
max(df2$date)
```
```{r}
length(unique(df2$date))
```
```{r}
unique(df2$user_submitted_review)
```
```{r}
unique(df2$title)
```
```{r}
unique(df2$total_purchased)
```
```{r}
unique(df2$customer_type)
```
### The Data Summary

The data has **`5 columns`** and **`5000 rows`**. The **`user_submitted_review`** and **`total_purchased`** columns have missing values. The data was recorded each day in 2019.

### Missing data

Remove rows where the **`user_submitted_review`** column has NA values.

```{r}
df2 <- df2 %>% filter(
  !(is.na(df2$user_submitted_review))
)
nrow(df2)
```
Replace NA values in the **`total_purchased`** column with the mean total_purchased. 

```{r}
total_purchased_mean <- df2 %>% filter(
  !(is.na(df2$total_purchased))
)
mean <- mean(total_purchased_mean$total_purchased)
mean
```
```{r}
df2 <- df2 %>% mutate(
  total_purchased = if_else(is.na(total_purchased),
                            ceiling(mean), total_purchased)
)
unique(df2$total_purchased)
```

```{r}
mean(df2$total_purchased)
```
### Create A Column To Determine If The Review Is Positive 

```{r}
unique(df2$user_submitted_review)
```
```{r}
pos_review <- function(string) {
  positive <- case_when(
    string == 'Awesome!' ~ TRUE,
    string == 'Never read a better book' ~ TRUE,
    string == 'I learned a lot' ~ TRUE,
    TRUE ~ FALSE
  )
}

df2 <- df2 %>% mutate(
  positive_review = unlist(map(user_submitted_review, pos_review))
)
head(df2)
```

### Split The Data By Date Before And Date After The Marketing Program

```{r}
head(df2$date)
```
```{r}
df2 <- df2 %>% mutate(
  date = ymd(date),
  marketing_program = if_else(date < ymd('2019/07/01'), 'Before', 'After')
)
head(df2)
```

Total sales before and after the marketing program.

```{r}
df2 %>% group_by(marketing_program) %>%
  summarise(total_sales = sum(total_purchased))
```

This doesn't show that the program has increased sales.

Below shows the total sales before and after the marketing program for business and individual customers.

```{r}
df2 %>% group_by(marketing_program, customer_type) %>%
  summarise(total_sales = sum(total_purchased))
```

The program may work better for business customers but at this level no improvement is shown for individual customers.

Below shows the total sales before and after the marketing program for positive and average or lower reviews. 

```{r}
df2 %>% group_by(marketing_program, positive_review) %>%
  summarise(total_sales = sum(total_purchased))
```

This shows an improvement in reviews since the program began.